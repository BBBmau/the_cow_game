<!DOCTYPE html>
<html>
<head>
    <title>3D Field Scene</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #debugView {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 2px solid white;
            background: rgba(0, 0, 0, 0.5);
        }
        #coordinates {
            position: fixed;
            top: 230px;
            right: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 2px solid white;
        }
    </style>
</head>
<body>
    <div id="debugView"></div>
    <div id="coordinates"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
        const helper = new THREE.PlaneHelper( plane, 1, 0xffff00 );
        scene.add( helper );
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Set up debug view
        const debugScene = new THREE.Scene();
        debugScene.background = new THREE.Color(0x000000);
        const debugCamera = new THREE.OrthographicCamera(-25, 25, 25, -25, 0.1, 1000);
        debugCamera.position.set(0, 50, 0);
        debugCamera.lookAt(0, 0, 0);
        const debugRenderer = new THREE.WebGLRenderer({ antialias: true });
        debugRenderer.setSize(200, 200);
        document.getElementById('debugView').appendChild(debugRenderer.domElement);

        // Player movement variables
        const moveSpeed = 0.15;
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // Create player character
        const playerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.5; // Half the height of the sphere
        player.castShadow = true;
        scene.add(player);

        // Add OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2;
        controls.enabled = false; // Disable orbit controls for first-person movement

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Add directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7CFC00,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add debug ground
        const debugGround = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshBasicMaterial({ color: 0x7CFC00, wireframe: true })
        );
        debugGround.rotation.x = -Math.PI / 2;
        debugScene.add(debugGround);

        // Add debug player indicator
        const debugPlayer = new THREE.Mesh(
            new THREE.CircleGeometry(0.5, 32),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        debugPlayer.rotation.x = -Math.PI / 2;
        debugScene.add(debugPlayer);

        // Add debug direction indicator
        const debugDirection = new THREE.Mesh(
            new THREE.ConeGeometry(0.5, 1, 32),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        debugDirection.rotation.x = -Math.PI / 2;
        debugDirection.position.y = 0.1;
        debugScene.add(debugDirection);

        // Add debug trees
        const debugTrees = new THREE.Group();
        debugScene.add(debugTrees);

        // Function to create a tree
        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Tree top
            const topGeometry = new THREE.ConeGeometry(1, 2, 8);
            const topMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 2;
            top.castShadow = true;
            treeGroup.add(top);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);

            // Add debug tree
            const debugTree = new THREE.Mesh(
                new THREE.CircleGeometry(0.3, 32),
                new THREE.MeshBasicMaterial({ color: 0x228B22 })
            );
            debugTree.rotation.x = -Math.PI / 2;
            debugTree.position.set(x, 0.1, z);
            debugTrees.add(debugTree);
        }

        // Add some trees
        for (let i = 0; i < 10; i++) {
            const x = Math.random() * 40 - 20;
            const z = Math.random() * 40 - 20;
            const tree = createTree(x, z);
        }

        // Position camera
        camera.position.set(0, 2, 5);
        camera.lookAt(player.position);

        // Keyboard event listeners
        document.addEventListener('keydown', (event) => {
            if (keys.hasOwnProperty(event.key.toLowerCase())) {
                keys[event.key.toLowerCase()] = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (keys.hasOwnProperty(event.key.toLowerCase())) {
                keys[event.key.toLowerCase()] = false;
            }
        });

        // Mouse movement for looking around
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                player.rotation.y -= movementX * 0.002;
                camera.rotation.y -= movementX * 0.002;
                
                // Update camera height based on mouse Y movement
                const currentHeight = camera.position.y;
                const newHeight = currentHeight + movementY * 0.01; // Adjust multiplier for sensitivity
                
                // Limit the height range
                if (newHeight > 1 && newHeight < 10) {
                    camera.position.y = newHeight;
                }
            }
        });

        // Click to lock pointer
        document.addEventListener('click', () => {
            document.body.requestPointerLock();
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Handle movement but why?
            if (keys.w) {
                player.position.x += Math.sin(player.rotation.y) * moveSpeed;
                player.position.z += Math.cos(player.rotation.y) * moveSpeed;
            }
            if (keys.s) {
                player.position.x -= Math.sin(player.rotation.y) * moveSpeed;
                player.position.z -= Math.cos(player.rotation.y) * moveSpeed;
            }
            if (keys.a) {
                player.position.x += Math.cos(player.rotation.y) * moveSpeed;
                player.position.z -= Math.sin(player.rotation.y) * moveSpeed;
            }
            if (keys.d) {
                player.position.x -= Math.cos(player.rotation.y) * moveSpeed;
                player.position.z += Math.sin(player.rotation.y) * moveSpeed;
            }

            // Keep player within bounds
            player.position.x = Math.max(-24, Math.min(24, player.position.x));
            player.position.z = Math.max(-24, Math.min(24, player.position.z));

            // Update camera position to follow player
            const cameraDistance = 5; // Distance behind player
            const cameraHeight = 3;   // Height above player
            
            // Calculate camera position based on player's position and rotation
            camera.position.x = player.position.x - Math.sin(player.rotation.y) * cameraDistance;
            camera.position.z = player.position.z - Math.cos(player.rotation.y) * cameraDistance;
            
            // Look at player with offset for camera tilt
            const lookAtPoint = new THREE.Vector3(
                player.position.x,
                player.position.y + 1, // Look slightly above player
                player.position.z
            );
            camera.lookAt(lookAtPoint);

            // Update debug view
            debugPlayer.position.set(player.position.x, 0.1, player.position.z);
            debugDirection.position.set(player.position.x, 0.1, player.position.z);
            debugDirection.rotation.z = -player.rotation.y;

            // Update coordinate display
            const coordinatesDiv = document.getElementById('coordinates');
            coordinatesDiv.innerHTML = `
                Position:<br>
                X: ${player.position.x.toFixed(2)}<br>
                Y: ${player.position.y.toFixed(2)}<br>
                Z: ${player.position.z.toFixed(2)}<br>
                Rotation: ${(player.rotation.y * (180/Math.PI)).toFixed(2)}°
            `;

            renderer.render(scene, camera);
            debugRenderer.render(debugScene, debugCamera);
        }

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();
    </script>
</body>
</html> 
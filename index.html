<!DOCTYPE html>
<html>
<head>
    <title>3D Field Scene</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #debugView {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 2px solid white;
            background: rgba(0, 0, 0, 0.5);
        }
        #coordinates {
            position: fixed;
            top: 230px;
            right: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 2px solid white;
        }
        #players {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 2px solid white;
        }

        #chatContainer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 400px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
        }
        #chatMessages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            color: white;
            font-family: monospace;
        }
        #chatInput {
            padding: 10px;
            border: none;
            border-top: 2px solid white;
            background: rgba(255, 255, 255, 0.9);
            font-family: monospace;
        }
        #chatInput:focus {
            outline: none;
        }
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        .chat-username {
            font-weight: bold;
            color: #4CAF50;
        }
        .chat-system {
            color: #ff9800;
            font-style: italic;
        }
        #loginScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #loginContainer {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            margin: 0 auto;
        }
        #usernameInput {
            padding: 10px;
            margin: 10px 0;
            width: 200px;
            border: 2px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }
        #startButton {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #45a049;
        }
        .hidden {
            display: none !important;
        }
        
        /* Inventory Pagination Styles */
        .nav-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 20px;
            background: #fff;
            color: #666;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .nav-btn:hover {
            border-color: #4CAF50;
            color: #4CAF50;
        }
        
        .nav-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
            color: white;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .inventory-item {
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            background: #fff;
            transition: all 0.2s ease;
        }
        
        .inventory-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .inventory-item.selected {
            border-color: #2196F3;
            background: #e3f2fd;
        }
        
        .inventory-item.locked {
            border-color: #ccc;
            background: #f5f5f5;
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .inventory-item.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        #leaderboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            max-height: 600px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 5px;
            display: none;
            z-index: 2000;
            font-family: monospace;
            overflow-y: auto;
        }
        
        /* Show cursor when leaderboard is active */
        body.leaderboard-active {
            cursor: default !important;
        }
        
        body.leaderboard-active * {
            cursor: default !important;
        }
        
        /* Force cursor visibility when leaderboard is active */
        body.leaderboard-active,
        body.leaderboard-active *,
        #leaderboard,
        #leaderboard * {
            cursor: default !important;
            pointer-events: auto !important;
        }
        
        #leaderboardContent {
            padding: 15px;
        }
        
        #leaderboard h1 {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 1px solid white;
            padding-bottom: 5px;
        }
        
        .leaderboard-section {
            margin-bottom: 15px;
        }
        
        .leaderboard-section h2 {
            color: white;
            margin-bottom: 8px;
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 3px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            padding: 5px;
            text-align: center;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.7rem;
            margin-bottom: 2px;
        }
        
        .stat-value {
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .players-list {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            padding: 4px 6px;
            margin-bottom: 3px;
            font-size: 0.8rem;
        }
        
        .player-name {
            color: white;
            font-weight: bold;
        }
        
        .player-stats {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.7rem;
        }
        
        .leaderboard-close-hint {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.7rem;
            margin-top: 10px;
            font-style: italic;
        }

        #customizationScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1500; /* Above game, below leaderboard */
        }
        #customizationContainer {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div id="loginScreen">
        <div id="loginContainer">
            <h2>Welcome to The Cow Game!</h2>
            <p>Enter your details to start playing:</p>
            <p>Keys:<br>
            Movement: W, A, S, D, Space<br>
            Moo: T<br>
            Exit Moo: Escape<br>
            View Stats & Leaderboard: Tab<br>
            Mouse: Click to lock camera â€¢ Tab/ESC to show cursor</p>
            <input type="text" id="usernameInput" placeholder="Username" maxlength="20">
            <br>
            <input type="password" id="passwordInput" placeholder="Password (optional - for saving progress)" maxlength="50" style="padding: 10px; margin: 10px 0; width: 200px; border: 2px solid #ccc; border-radius: 5px; font-size: 16px;">
            <br>
            <button id="startButton">Start Playing</button>
            <p style="font-size: 12px; color: #666; margin-top: 10px;">
                <strong>Guest Mode:</strong> Just enter a username (progress won't be saved)<br>
                <strong>Account Mode:</strong> Enter username + password (progress will be saved)
            </p>

            <p> made with love - mau </p>
        </div>
    </div>
    <div id="debugView"></div>
    <div id="coordinates"></div>
    <div id="players"></div>
    <div id="chatContainer">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Type a message...">
    </div>
    
    <!-- Leaderboard -->
    <div id="leaderboard">
        <div id="leaderboardContent">
            <h1>Stats</h1>
            
            <!-- Player Stats Section -->
            <div class="leaderboard-section">
                <h2>Your Stats</h2>
                <div class="stats-grid" id="playerStatsGrid">
                    <!-- Player stats will be populated here -->
                </div>
            </div>
            
            <!-- Global Stats Section -->
            <div class="leaderboard-section">
                <h2>Global Stats</h2>
                <div class="stats-grid" id="globalStatsGrid">
                    <!-- Global stats will be populated here -->
                </div>
            </div>
            
            <!-- Online Players Section -->
            <div class="leaderboard-section">
                <h2>Online Players</h2>
                <div class="players-list" id="onlinePlayersList">
                    <!-- Online players will be populated here -->
                </div>
            </div>
            
            <div class="leaderboard-close-hint">
                Press Tab to close
            </div>
        </div>
    </div>

    <!-- Customization Screen -->
    <div id="customizationScreen" class="hidden">
        <div id="customizationContainer">
            <h2>Customize Your Cow</h2>
            <div style="display: flex; gap: 30px; margin: 20px 0;">
                <!-- Left column: Cow preview and color wheel -->
                <div style="flex: 1; text-align: center;">
                    <h3 style="margin-bottom: 10px; color: #333;">Preview</h3>
                    <canvas id="cowPreviewCanvas" width="300" height="300" style="border: 2px solid #ddd; border-radius: 8px; margin-bottom: 20px;"></canvas>
                    <div id="color-picker-wheel" style="display: flex; justify-content: center; min-height: 280px; width: 100%; border: 1px solid #ccc; border-radius: 8px; background: #f9f9f9; padding: 10px;"></div>
                </div>
                
                <!-- Right column: Inventory -->
                <div style="flex: 1; text-align: center;">
                    <h3 style="margin-bottom: 10px; color: #333;">Inventory</h3>
                    <div id="inventoryContainer" style="border: 2px solid #ddd; border-radius: 8px; background: #f9f9f9; padding: 20px; min-height: 580px;">
                        <!-- Page Navigation -->
                        <div id="inventoryNavigation" style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;">
                            <button class="nav-btn active" data-page="hats">Hats</button>
                            <button class="nav-btn" data-page="glasses">Glasses</button>
                            <button class="nav-btn" data-page="accessories">Accessories</button>
                            <button class="nav-btn" data-page="patterns">Patterns</button>
                            <button class="nav-btn" data-page="effects">Effects</button>
                        </div>
                        
                        <!-- Single Grid for all items -->
                        <div id="inventoryGrid" class="inventory-grid">
                            <!-- Items will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
            <button id="saveCustomizationButton" style="margin-top: 20px;">Save & Close</button>
            <p style="font-size: 12px; color: #666; margin-top: 10px;">
                Press ESC to close without saving.
            </p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script type="module">
        import { createCow, updateCowMovement } from './cow.js';
        import { initializeUI, addChatMessage, updateLeaderboard, isLeaderboardActive } from './ui.js';

        let username = '';
        let cowColor = '#ffffff';
        let gameStarted = false;

        let globalStats = {
            totalPlayers: 0,
            totalHayEaten: 0,
            serverStartTime: Date.now()
        };
        let playerStats = {
            level: 1,
            experience: 0,
            hayEaten: 0,
            timePlayed: 0,
            coins: 0
        };
        let otherPlayers = new Map();
        
        // --- Core Game Variables ---
        let player;
        let scene;
        
        function updatePlayerCow(newColor) {
            if (!player) return;

            const newHexColor = new THREE.Color(newColor);

            // The body is the first child (index 0), head is the second (index 1)
            const body = player.children[0];
            const head = player.children[1];

            if (body && body.material) {
                body.material.color.set(newHexColor);
            }
            if (head && head.material) {
                head.material.color.set(newHexColor);
            }
        }

        async function startGame(newUsername, password) {
            username = newUsername.trim();
            const pass = password.trim();
        
            if (!username) {
                alert('Please enter a username!');
                return;
            }
        
            // Set auth info based on whether a password was provided
            if (pass) {
                const authResult = await authenticateUser(username, pass);
                if (!authResult.success) {
                    alert(authResult.message || 'Authentication failed!');
                    return; // Stop if auth fails
                }
            } else {
                authInfo = {
                    isAuthenticated: false,
                    username: null,
                    password: null
                };
            }
            
            // Load saved color from Redis
            try {
                const response = await fetch(`/user/${encodeURIComponent(username)}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.color) {
                        cowColor = data.color;
                        console.log(`Loaded saved color for ${username}: ${cowColor}`);
                    }
                }
            } catch (error) {
                console.error('Error loading color from Redis:', error);
            }
        
            document.getElementById('loginScreen').classList.add('hidden');
            gameStarted = true;
            initGame(); // Call initGame without arguments
            
            // Store the loaded color to apply after WebSocket connection
            if (cowColor && cowColor !== '#ffffff') {
                window.loadedColor = cowColor;
            }
        }

        initializeUI({
            onStartGame: startGame,
            onCowColorChange: (newColor, sendToServer = true) => {
                cowColor = newColor; // 1. Update state
                updatePlayerCow(newColor); // 2. Update model's color directly

                // 3. Tell server (only if sendToServer is true)
                if (sendToServer && window.ws && window.ws.readyState === WebSocket.OPEN) {
                    window.ws.send(JSON.stringify({
                        type: 'update_color',
                        color: newColor
                    }));
                }
            },
            onSendMessage: (message) => {
                if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                    window.ws.send(JSON.stringify({ type: 'chat_message', text: message }));
                }
            }
        }, () => ({
            gameStarted,
            playerStats,
            globalStats,
            otherPlayers,
            username,
            cowColor // Pass cowColor to UI
        }));

        // Store authentication info for use in initGame
        let authInfo = {
            isAuthenticated: false,
            username: null,
            password: null
        };
        
        // Authentication function - now just validates and stores info
        async function authenticateUser(username, password) {
            // For now, just store the auth info and validate in initGame
            authInfo = {
                isAuthenticated: true,
                username: username,
                password: password
            };
            return { success: true, message: 'Ready to connect' };
        }

        function initGame() {
            console.log('Initializing game...');
            
            // WebSocket connection with timeout
            const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            const wsHost = window.location.host;
            const wsUrl = `${wsProtocol}://${wsHost}`;
            
            console.log('Connecting to WebSocket:', wsUrl);
            window.ws = new WebSocket(wsUrl);
            let clientId = null;
            
            // Add connection timeout
            const connectionTimeout = setTimeout(() => {
                if (window.ws.readyState === WebSocket.CONNECTING) {
                    console.error('WebSocket connection timeout');
                    window.ws.close();
                    alert('Connection timeout. Please try again.');
                    // Reset to login screen
                    gameStarted = false;
                    document.getElementById('loginScreen').classList.remove('hidden');
                }
            }, 10000); // 10 second timeout

            // Set up scene, camera, and renderer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Set up debug view
            const debugScene = new THREE.Scene();
            debugScene.background = new THREE.Color(0x000000);
            const debugCamera = new THREE.OrthographicCamera(-25, 25, 25, -25, 0.1, 1000);
            debugCamera.position.set(0, 50, 0);
            debugCamera.lookAt(0, 0, 0);
            const debugRenderer = new THREE.WebGLRenderer({ antialias: true });
            debugRenderer.setSize(200, 200);
            document.getElementById('debugView').appendChild(debugRenderer.domElement);

            // Player movement variables
            const moveSpeed = 0.15;
            const keys = {
                w: false,
                a: false,
                s: false,
                d: false,
                ' ': false  // Add spacebar for jumping
            };

            function createNameLabel(text) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;  // Increased canvas size for better resolution
                canvas.height = 128;

                // Draw text with multiple outlines for better visibility
                context.font = 'Bold 48px Arial';  // Increased font size
                context.textAlign = 'center';
                context.textBaseline = 'middle';

                // Draw multiple outlines for better visibility
                context.strokeStyle = 'black';
                context.lineWidth = 8;
                context.strokeText(text, canvas.width / 2, canvas.height / 2);
                
                // Draw white fill
                context.fillStyle = 'white';
                context.fillText(text, canvas.width / 2, canvas.height / 2);

                // Create sprite
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    depthTest: false  // Makes text always render on top
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(3, 0.75, 1);  // Adjusted scale for better visibility
                sprite.renderOrder = 1;  // Ensures text renders on top

                return sprite;
            }

            function updateNameLabel(cow, newUsername) {
                // Find and remove only the name label sprite
                for (let i = cow.children.length - 1; i >= 0; i--) {
                    const child = cow.children[i];
                    if (child instanceof THREE.Sprite) {
                        cow.remove(child);
                    }
                }
                // Create and add new label
                const nameLabel = createNameLabel(newUsername);
                cow.add(nameLabel);
                nameLabel.position.y = 3;  // Raised position for better visibility
            }

            // Map to track active speech bubbles to ensure only one is shown per player
            const activeSpeechBubbles = new Map();

            function showInWorldText(targetObject, text, type, ownerId) {
                // For speech bubbles, manage timers and existing bubbles
                if (type === 'speech') {
                    const bubbles = activeSpeechBubbles.get(ownerId) || [];

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const font = '32px Arial';
                    ctx.font = font;
                    const textMetrics = ctx.measureText(text);

                    const padding = 20;
                    const bubbleWidth = textMetrics.width + (padding * 2);
                    const bubbleHeight = 32 + (padding * 2);
                    const tailHeight = 20;

                    canvas.width = bubbleWidth;
                    canvas.height = bubbleHeight + tailHeight;

                    const x = 0, y = 0;
                    const width = bubbleWidth, height = bubbleHeight;
                    const radius = 15;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(width / 2 - 15, height - 2);
                    ctx.lineTo(width / 2, height + tailHeight);
                    ctx.lineTo(width / 2 + 15, height - 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = 'black';
                    ctx.font = font;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, width / 2, height / 2);

                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                    const sprite = new THREE.Sprite(material);
                    const spriteHeight = canvas.height / 100;
                    sprite.scale.set(bubbleWidth / 100, spriteHeight, 1.0);
                    
                    scene.add(sprite);

                    const newBubble = {
                        sprite: sprite,
                        texture: texture,
                        material: material,
                        target: targetObject,
                        creationTime: Date.now(),
                        height: spriteHeight
                    };

                    bubbles.push(newBubble);

                    // Limit to 3 bubbles per player
                    if (bubbles.length > 3) {
                        const oldestBubble = bubbles.shift(); // Remove the oldest bubble
                        scene.remove(oldestBubble.sprite);
                        oldestBubble.texture.dispose();
                        oldestBubble.material.dispose();
                    }

                    activeSpeechBubbles.set(ownerId, bubbles);

                } else { // 'floating' type for hay
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 128;

                    context.font = 'Bold 48px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.strokeStyle = 'black';
                    context.lineWidth = 6;
                    context.strokeText(text, canvas.width / 2, canvas.height / 2);
                    context.fillStyle = '#00FF00';
                    context.fillText(text, canvas.width / 2, canvas.height / 2);

                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                    const sprite = new THREE.Sprite(material);
                    sprite.scale.set(2, 1, 1);

                    const startPosition = targetObject.position.clone();
                    sprite.position.copy(startPosition).y += 3;
                    scene.add(sprite);

                    const duration = 1500;
                    const floatHeight = 2;
                    const startTime = Date.now();

                    function animateMessage() {
                        const elapsed = Date.now() - startTime;
                        const progress = elapsed / duration;

                        if (progress < 1) {
                            sprite.position.y = startPosition.y + 3 + (progress * floatHeight);
                            sprite.material.opacity = 1.0 - progress;
                            requestAnimationFrame(animateMessage);
                        } else {
                            scene.remove(sprite);
                            texture.dispose();
                            material.dispose();
                        }
                    }

                    animateMessage();
                }
            }

            // Create player character with custom color
            player = createCow(cowColor);
            player.position.y = 0;
            player.castShadow = true;
            scene.add(player);

            // Add name label to player
            updateNameLabel(player, username);

            // Add OrbitControls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;
            controls.enabled = false;

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7CFC00,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;  // Set ground to y=0
            ground.receiveShadow = true;
            scene.add(ground);

            // Add debug ground
            const debugGround = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshBasicMaterial({ color: 0x7CFC00, wireframe: true })
            );
            debugGround.rotation.x = -Math.PI / 2;
            debugGround.position.y = 0;  // Match the ground position
            debugScene.add(debugGround);

            // Update debug player indicator
            const debugPlayer = new THREE.Mesh(
                new THREE.CircleGeometry(0.5, 32),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            debugPlayer.rotation.x = -Math.PI / 2;
            debugScene.add(debugPlayer);

            // Add debug direction indicator
            const debugDirection = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            debugDirection.rotation.x = -Math.PI / 2;
            debugDirection.position.y = 0.1;
            debugScene.add(debugDirection);

            // Track tree and hay positions to avoid intersections
            const treePositions = [];
            const hayPositions = [];
            const hayObjects = new Map(); // Track hay objects for collision detection

            // Add debug trees
            const debugTrees = new THREE.Group();
            debugScene.add(debugTrees);

            // Add debug hay
            const debugHay = new THREE.Group();
            debugScene.add(debugHay);

            // Function to create a tree
            function createTree(x, z) {
                const treeGroup = new THREE.Group();

                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.5;  // Half the trunk height
                trunk.castShadow = true;
                treeGroup.add(trunk);

                // Tree top
                const topGeometry = new THREE.ConeGeometry(1, 2, 8);
                const topMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 2;  // Position above trunk
                top.castShadow = true;
                treeGroup.add(top);

                treeGroup.position.set(x, 0, z);  // Set tree base at ground level
                scene.add(treeGroup);

                // Add debug tree
                const debugTree = new THREE.Mesh(
                    new THREE.CircleGeometry(0.3, 32),
                    new THREE.MeshBasicMaterial({ color: 0x228B22 })
                );
                debugTree.rotation.x = -Math.PI / 2;
                debugTree.position.set(x, 0.1, z);  // Slightly above ground for visibility
                debugTrees.add(debugTree);

                // Track tree position
                treePositions.push({ x, z });
            }

            // Function to create hay
            function createHay(x, z, hayId = null) {
                const hayGroup = new THREE.Group();
                const id = hayId || `hay_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;

                // Create hay bale using multiple cylinders for a realistic look
                const hayBaleGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 8);
                const hayMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xDAA520,  // Goldenrod color for hay
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                // Main hay bale
                const hayBale = new THREE.Mesh(hayBaleGeometry, hayMaterial);
                hayBale.position.y = 0.15;  // Half the height
                hayBale.castShadow = true;
                hayBale.receiveShadow = true;
                hayGroup.add(hayBale);

                // Add some hay strands on top for texture
                for (let i = 0; i < 8; i++) {
                    const strandGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2, 4);
                    const strand = new THREE.Mesh(strandGeometry, hayMaterial);
                    strand.position.y = 0.4;
                    strand.rotation.x = Math.random() * 0.3 - 0.15;
                    strand.rotation.z = Math.random() * 0.3 - 0.15;
                    strand.position.x = (Math.random() - 0.5) * 0.6;
                    strand.position.z = (Math.random() - 0.5) * 0.6;
                    hayGroup.add(strand);
                }

                hayGroup.position.set(x, 0, z);
                hayGroup.userData = { id: id, type: 'hay' };
                scene.add(hayGroup);

                // Add debug hay indicator
                const debugHayIndicator = new THREE.Mesh(
                    new THREE.CircleGeometry(0.25, 32),
                    new THREE.MeshBasicMaterial({ color: 0xDAA520 })
                );
                debugHayIndicator.rotation.x = -Math.PI / 2;
                debugHayIndicator.position.set(x, 0.05, z);
                debugHay.add(debugHayIndicator);

                // Track hay position and object
                hayPositions.push({ x, z, id: id });
                hayObjects.set(id, hayGroup);

                return hayGroup;
            }

            // Function to check if a position is clear of obstacles
            function isPositionClear(x, z, radius = 1.0) {
                // Check against trees
                for (const tree of treePositions) {
                    const distance = Math.sqrt((x - tree.x) ** 2 + (z - tree.z) ** 2);
                    if (distance < radius) return false;
                }
                
                // Check against existing hay
                for (const hay of hayPositions) {
                    const distance = Math.sqrt((x - hay.x) ** 2 + (z - hay.z) ** 2);
                    if (distance < radius) return false;
                }
                
                return true;
            }

            // Function to find a random clear position
            function findRandomClearPosition() {
                let attempts = 0;
                const maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    const x = Math.random() * 40 - 20;
                    const z = Math.random() * 40 - 20;
                    
                    if (isPositionClear(x, z, 1.5)) {
                        return { x, z };
                    }
                    attempts++;
                }
                
                // If no clear position found, return a position at the edge
                return { x: 18, z: 18 };
            }

            // Add some trees
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 40 - 20;
                const z = Math.random() * 40 - 20;
                createTree(x, z);
            }

            // Position camera
            camera.position.set(0, 2, 5);
            camera.lookAt(player.position);

            // Add camera rotation angle
            let cameraAngle = 0;

            // Keyboard event listeners
            document.addEventListener('keydown', (event) => {
                if (keys.hasOwnProperty(event.key.toLowerCase())) {
                    keys[event.key.toLowerCase()] = true;
                }
            });

            document.addEventListener('keyup', (event) => {
                if (keys.hasOwnProperty(event.key.toLowerCase())) {
                    keys[event.key.toLowerCase()] = false;
                }
            });

            // Mouse movement for looking around (when pointer is locked)
            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === document.body && !isLeaderboardActive) {
                    const movementX = event.movementX || 0;
                    const movementY = event.movementY || 0;
                    
                    // Update camera angle for orbiting
                    cameraAngle -= movementX * 0.002;
                    
                    // Update camera height based on mouse Y movement
                    const currentHeight = camera.position.y;
                    const newHeight = currentHeight + movementY * 0.01;
                    
                    // Limit the height range
                    if (newHeight > 1 && newHeight < 10) {
                        camera.position.y = newHeight;
                    }
                }
            });

            // Click to lock pointer for mouse look (only when not already locked)
            document.addEventListener('click', (event) => {
                // Don't lock pointer if clicking on UI elements or if leaderboard is open
                if (event.target.closest('#leaderboard, #chatContainer, #players, #coordinates, #debugView') || isLeaderboardActive) {
                    return;
                }
                
                // Only lock if not already locked and leaderboard is not active
                if (!document.pointerLockElement && !isLeaderboardActive) {
                    document.body.requestPointerLock();
                }
            });
            
            // Add visual indicator for mouse lock state
            document.addEventListener('pointerlockchange', () => {
                console.log('=== POINTER LOCK CHANGE ===');
                console.log('New pointer lock element:', document.pointerLockElement);
                console.log('Is leaderboard active?', isLeaderboardActive);
                
                if (document.pointerLockElement === document.body) {
                    console.log('Mouse locked - you can look around');
                } else {
                    console.log('Mouse unlocked - click to lock for mouse look');
                }
            });

            // WebSocket event handlers
            window.ws.onopen = () => {
                console.log('Connected to server');
                clearTimeout(connectionTimeout); // Clear the timeout since we connected
                
                if (authInfo.isAuthenticated) {
                    // Send authentication first for account mode
                    console.log('Sending authentication for:', authInfo.username);
                    window.ws.send(JSON.stringify({
                        type: 'authenticate',
                        username: authInfo.username,
                        password: authInfo.password
                    }));
                }
            };

            // WebSocket error handler
            window.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                clearTimeout(connectionTimeout);
                alert('Connection error. Please check your internet connection and try again.');
                // Reset to login screen
                gameStarted = false;
                document.getElementById('loginScreen').classList.remove('hidden');
            };

            // WebSocket close handler
            window.ws.onclose = (event) => {
                console.log('WebSocket connection closed:', event.code, event.reason);
                clearTimeout(connectionTimeout);
                
                if (event.code === 1008) {
                    alert('Server is at capacity. Please try again later.');
                } else if (event.code !== 1000) {
                    alert('Connection lost. Please refresh the page.');
                }
                
                // Reset to login screen if game was started
                if (gameStarted) {
                    gameStarted = false;
                    document.getElementById('loginScreen').classList.remove('hidden');
                }
            };

            window.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('Received message:', data);
                
                switch (data.type) {
                    case 'auth_result':
                        console.log('Authentication result:', data);
                        if (data.success) {
                            // Authentication successful, now send username and color
                            console.log('Auth successful, sending username and color');
                            window.ws.send(JSON.stringify({
                                type: 'set_username',
                                username: authInfo.username,
                                color: cowColor
                            }));
                        } else {
                            // Authentication failed
                            alert(data.message || 'Authentication failed!');
                            // Redirect back to login
                            window.location.reload();
                        }
                        break;

                    case 'username_error':
                        console.log('Username error:', data.message);
                        alert(data.message);
                        // Redirect back to login to choose a different username
                        window.location.reload();
                        break;
                        
                    case 'init':
                        clientId = data.id;
                        console.log('Initialized with ID:', clientId);
                        
                        // Apply loaded color if we have one
                        if (window.loadedColor && window.loadedColor !== '#ffffff') {
                            updatePlayerCow(window.loadedColor);
                            cowColor = window.loadedColor;
                            
                            // Send color update to server
                            window.ws.send(JSON.stringify({
                                type: 'update_color',
                                color: window.loadedColor
                            }));
                            
                            delete window.loadedColor;
                        }
                        
                        // Update player stats if provided
                        if (data.stats) {
                            console.log('Received stats from server:', data.stats);
                            playerStats = { ...playerStats, ...data.stats };
                            console.log('Updated playerStats:', playerStats);
                        } else {
                            console.log('No stats received from server');
                        }
                        
                        // Update global stats
                        if (data.globalStats) {
                            globalStats = { ...globalStats, ...data.globalStats };
                            console.log('Updated globalStats:', globalStats);
                        }
                        
                        // Update leaderboard if it's open
                        if (isLeaderboardActive) {
                            updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                        }
                        
                        // Create other players that are already in the game
                        data.players.forEach(playerData => {
                            if (playerData.id !== clientId) {
                                console.log('Creating other player with stats:', playerData);
                                createOtherPlayer(playerData);
                            }
                        });
                        
                        // Create existing hay on the map
                        if (data.hay) {
                            data.hay.forEach(hayData => {
                                console.log('Creating existing hay:', hayData);
                                createHay(hayData.x, hayData.z, hayData.id);
                            });
                        }
                        
                        addChatMessage('Welcome to the game!', 'system');
                        break;
                        
                    case 'stats_updated':
                        console.log('Received stats_updated message:', data);
                        // Update player stats
                        if (data.stats) {
                            playerStats = { ...playerStats, ...data.stats };
                        }
                        
                        // If this is a new user, redirect to customization
                        if (data.isNewUser) {
                            console.log('New user detected, redirecting to customization');
                            // Exit pointer lock if active
                            if (document.pointerLockElement) {
                                document.exitPointerLock();
                            }
                            // Show customization screen with current color
                            const customizationScreen = document.getElementById('customizationScreen');
                            if (customizationScreen) {
                                customizationScreen.classList.remove('hidden');
                                
                                // Check if user is guest (no password provided)
                                const isGuest = !authInfo.isAuthenticated;
                                
                                if (isGuest) {
                                    // Disable customization for guests
                                    const colorWheel = document.getElementById('color-picker-wheel');
                                    const saveButton = document.getElementById('saveCustomizationButton');
                                    const inventoryContainer = document.getElementById('inventoryContainer');
                                    
                                    if (colorWheel) colorWheel.style.opacity = '0.5';
                                    if (saveButton) saveButton.disabled = true;
                                    if (inventoryContainer) inventoryContainer.style.opacity = '0.5';
                                    
                                    // Add guest message
                                    const guestMessage = document.createElement('div');
                                    guestMessage.innerHTML = '<p style="color: #ff6b6b; font-weight: bold; margin: 20px 0;">Guest users cannot customize their cow. Please create an account to unlock customization features.</p>';
                                    guestMessage.id = 'guestMessage';
                                    customizationScreen.insertBefore(guestMessage, customizationScreen.firstChild);
                                } else {
                                    // For authenticated users, just show the normal customization screen
                                    // This will initialize everything properly (inventory, cow preview, color picker)
                                    if (typeof showCustomizationScreen === 'function') {
                                        showCustomizationScreen(cowColor);
                                    }
                                }
                            }
                        } else {
                            console.log('Not a new user, isNewUser:', data.isNewUser);
                        }
                        break;

                    case 'player_joined':
                        console.log('Player joined:', data);
                        createOtherPlayer(data);
                        addChatMessage(`${data.username} joined the game`, 'system');
                        if (isLeaderboardActive) {
                            updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                        }
                        break;

                    case 'color_update':
                        console.log('Color update:', data);
                        data.players.forEach(playerData => {
                            const existingPlayer = otherPlayers.get(playerData.id);
                            if (existingPlayer) {
                                // Update the cow's color
                                const oldCow = existingPlayer.cow;
                                const newCow = createCow(playerData.color);
                                newCow.position.copy(oldCow.position);
                                newCow.rotation.copy(oldCow.rotation);
                                newCow.castShadow = true;
                                
                                // Copy the name label
                                const nameLabel = oldCow.children.find(child => child instanceof THREE.Sprite);
                                if (nameLabel) {
                                    newCow.add(nameLabel.clone());
                                }
                                
                                // Replace the old cow with the new one
                                scene.remove(oldCow);
                                scene.add(newCow);
                                
                                // Update the player data
                                existingPlayer.cow = newCow;
                                existingPlayer.color = playerData.color;
                            }
                        });
                        break;

                    case 'position_update':
                        updateOtherPlayer(data);
                        break;

                    case 'player_left':
                        console.log('Player left:', data);
                        removeOtherPlayer(data.id);
                        addChatMessage(`${data.username} left the game`, 'system');
                        if (isLeaderboardActive) {
                            updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                        }
                        break;

                    case 'chat_message':
                        // Find the player who sent the message
                        let chatTargetPlayer = null;
                        if (data.playerId === clientId) {
                            chatTargetPlayer = player; // It's the local player
                        } else if (otherPlayers.has(data.playerId)) {
                            chatTargetPlayer = otherPlayers.get(data.playerId).cow;
                        }

                        if (chatTargetPlayer) {
                            showInWorldText(chatTargetPlayer, data.text, 'speech', data.playerId);
                        }
                        // Also add it to the chat box
                        addChatMessage(data);
                        break;

                    case 'hay_spawned':
                        console.log('Hay spawned:', data);
                        createHay(data.position.x, data.position.z, data.hayId);
                        break;

                    case 'hay_collected':
                        console.log('Hay collected by:', data.username);
                        // Remove the hay from the scene
                        if (data.hayId && hayObjects.has(data.hayId)) {
                            const hayObject = hayObjects.get(data.hayId);
                            scene.remove(hayObject);
                            hayObjects.delete(data.hayId);
                            
                            // Remove from hay positions
                            const hayIndex = hayPositions.findIndex(hay => hay.id === data.hayId);
                            if (hayIndex !== -1) {
                                hayPositions.splice(hayIndex, 1);
                            }
                        }
                        
                        // Show floating message
                        let hayTargetPlayer = null;
                        if (data.playerId === clientId) {
                            hayTargetPlayer = player; // It's the local player
                        } else if (otherPlayers.has(data.playerId)) {
                            hayTargetPlayer = otherPlayers.get(data.playerId).cow;
                        }
                        
                        if (hayTargetPlayer) {
                            showInWorldText(hayTargetPlayer, '+1 Hay', 'floating', data.playerId);
                        }
                        break;

                    case 'stats_updated':
                        console.log('Stats updated:', data.stats);
                        playerStats = { ...playerStats, ...data.stats };
                        if (isLeaderboardActive) {
                            updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                        }
                        break;

                    case 'level_up':
                        console.log('Level up! New level:', data.newLevel);
                        addChatMessage(`Congratulations! You reached level ${data.newLevel}!`, 'system');
                        break;
                        
                    case 'global_stats_updated':
                        console.log('Global stats updated:', data.globalStats);
                        globalStats = { ...globalStats, ...data.globalStats };
                        if (isLeaderboardActive) {
                            updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                        }
                        break;
                        
                    case 'player_stats_updated':
                        console.log('Player stats updated:', data);
                        // Update the other player's stats in our local map
                        if (otherPlayers.has(data.playerId)) {
                            const playerData = otherPlayers.get(data.playerId);
                            playerData.level = data.stats.level;
                            playerData.hayEaten = data.stats.hayEaten;
                            playerData.experience = data.stats.experience;
                            otherPlayers.set(data.playerId, playerData);
                            
                            // Update leaderboard if it's open
                            if (isLeaderboardActive) {
                                updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                            }
                        }
                        break;
                }
            };

            window.ws.onclose = () => {
                console.log('Disconnected from server');
            };

            function createOtherPlayer(data) {
                const otherPlayer = createCow(data.color || '#ffffff');
                otherPlayer.position.set(data.position.x, data.position.y, data.position.z);
                otherPlayer.rotation.y = data.rotation;
                otherPlayer.castShadow = true;
                scene.add(otherPlayer);

                // Add name label
                updateNameLabel(otherPlayer, data.username || 'Anonymous');

                otherPlayers.set(data.id, {
                    cow: otherPlayer,
                    username: data.username || 'Anonymous',
                    color: data.color || '#ffffff',
                    level: data.stats?.level || 1,
                    hayEaten: data.stats?.hayEaten || 0,
                    experience: data.stats?.experience || 0
                });
                updatePlayersList();
            }

            function updateOtherPlayer(data) {
                const playerData = otherPlayers.get(data.id);
                if (playerData) {
                    playerData.cow.position.set(data.position.x, data.position.y, data.position.z);
                    playerData.cow.rotation.y = data.rotation;
                    if (data.username && data.username !== playerData.username) {
                        playerData.username = data.username;
                        updateNameLabel(playerData.cow, data.username);
                    }
                    updatePlayersList();
                }
            }

            function updatePlayerUsername(data) {
                const playerData = otherPlayers.get(data.id);
                if (playerData) {
                    playerData.username = data.username;
                    updateNameLabel(playerData.cow, data.username);
                    updatePlayersList();
                }
            }

            function removeOtherPlayer(id) {
                const playerData = otherPlayers.get(id);
                if (playerData) {
                    scene.remove(playerData.cow);
                    otherPlayers.delete(id);
                    updatePlayersList();
                }
            }



            function updatePlayersList() {
                const playersDiv = document.getElementById('players');
                playersDiv.innerHTML = `
                    Players Online: ${otherPlayers.size + 1}<br>
                    Your Username: ${username}<br>
                    Other Players:<br>
                    ${Array.from(otherPlayers.values()).map(player => player.username).join('<br>')}
                `;
            }



            // Function to check collision with hay
            function checkHayCollision() {
                const playerPosition = player.position;
                const collisionRadius = 1.0; // Distance to trigger hay collection
                
                for (const [hayId, hayObject] of hayObjects) {
                    const hayPosition = hayObject.position;
                    const distance = Math.sqrt(
                        Math.pow(playerPosition.x - hayPosition.x, 2) + 
                        Math.pow(playerPosition.z - hayPosition.z, 2)
                    );
                    
                    if (distance < collisionRadius) {
                        // Collect the hay
                        collectHay(hayId, hayObject);
                        break; // Only collect one hay at a time
                    }
                }
            }

            // Function to collect hay
            function collectHay(hayId, hayObject) {
                // Remove hay from scene
                scene.remove(hayObject);
                hayObjects.delete(hayId);
                
                // Remove from hay positions
                const hayIndex = hayPositions.findIndex(hay => hay.id === hayId);
                if (hayIndex !== -1) {
                    hayPositions.splice(hayIndex, 1);
                }
                
                // Send collection message to server
                if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                    window.ws.send(JSON.stringify({
                        type: 'collect_hay',
                        hayId: hayId,
                        position: {
                            x: player.position.x,
                            y: player.position.y,
                            z: player.position.z
                        }
                    }));
                }
            }

            // Time tracking for stats
            let gameStartTime = Date.now();
            let lastTimeUpdate = 0;
            let lastLeaderboardUpdate = 0;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Update cow movement
                updateCowMovement(player, keys, moveSpeed, camera);

                // Check for hay collisions
                checkHayCollision();

                // Update speech bubble positions
                const BUBBLE_LIFESPAN = 5000; // 5 seconds
                const BUBBLE_STACK_GAP = 0.2;

                activeSpeechBubbles.forEach((bubbles, ownerId) => {
                    let currentYOffset = 3.5;
                    
                    // Iterate backwards to safely remove bubbles
                    for (let i = bubbles.length - 1; i >= 0; i--) {
                        const bubble = bubbles[i];
                        const age = Date.now() - bubble.creationTime;

                        if (age > BUBBLE_LIFESPAN) {
                            // Remove the bubble
                            scene.remove(bubble.sprite);
                            bubble.texture.dispose();
                            bubble.material.dispose();
                            bubbles.splice(i, 1);
                        } else {
                            // Update position
                            bubble.sprite.position.copy(bubble.target.position);
                            bubble.sprite.position.y += currentYOffset;
                            
                            // Move the next bubble up
                            currentYOffset += bubble.height + BUBBLE_STACK_GAP;
                        }
                    }

                    // If no bubbles are left for this owner, remove the entry from the map
                    if (bubbles.length === 0) {
                        activeSpeechBubbles.delete(ownerId);
                    }
                });

                // Update time played every second
                const currentTime = Date.now();
                if (currentTime - lastTimeUpdate >= 1000) {
                    playerStats.timePlayed = Math.floor((currentTime - gameStartTime) / 1000);
                    lastTimeUpdate = currentTime;
                }
                
                // Update leaderboard every 5 seconds if open
                if (isLeaderboardActive && currentTime - lastLeaderboardUpdate >= 5000) {
                    updateLeaderboard(playerStats, globalStats, otherPlayers, username);
                    lastLeaderboardUpdate = currentTime;
                }

                // Send position update to server
                if (window.ws.readyState === WebSocket.OPEN) {
                    window.ws.send(JSON.stringify({
                        type: 'update_position',
                        position: {
                            x: player.position.x,
                            y: player.position.y,
                            z: player.position.z
                        },
                        rotation: player.rotation.y
                    }));
                }

                // Update camera position to orbit around player
                const cameraDistance = 5;
                
                // Calculate camera position based on orbit angle
                camera.position.x = player.position.x + Math.sin(cameraAngle) * cameraDistance;
                camera.position.z = player.position.z + Math.cos(cameraAngle) * cameraDistance;
                
                // Look at player with offset for camera tilt
                const lookAtPoint = new THREE.Vector3(
                    player.position.x,
                    player.position.y + 1,
                    player.position.z
                );
                camera.lookAt(lookAtPoint);

                // Update debug view
                debugPlayer.position.set(player.position.x, 0.1, player.position.z);
                debugDirection.position.set(player.position.x, 0.1, player.position.z);
                debugDirection.rotation.z = -player.rotation.y;

                // Update coordinate display
                const coordinatesDiv = document.getElementById('coordinates');
                coordinatesDiv.innerHTML = `
                    Position:<br>
                    X: ${player.position.x.toFixed(2)}<br>
                    Y: ${player.position.y.toFixed(2)}<br>
                    Z: ${player.position.z.toFixed(2)}<br>
                    Rotation: ${(player.rotation.y * (180/Math.PI)).toFixed(2)}Â°
                `;

                renderer.render(scene, camera);
                debugRenderer.render(debugScene, debugCamera);
            }

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate();
        }


    </script>
</body>
</html> 